<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android学习笔记---深入理解View#03 | Kevin&#39;s GHB</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上一篇的结尾中,我们发现了View的绘制发生在ViewRootImpl的performTraversals()中.而且在其中先后调用了performMeasure(),performLayout(),performDraw().如此一来,我们又有了新的猎物了.就像美食一样,好吃的东西一定要仔细地品尝.在上主菜之前,我们先来点开胃菜.我们先来了解一下Android是怎样绘制View的.(官方的文档H">
<meta property="og:type" content="article">
<meta property="og:title" content="Android学习笔记---深入理解View#03">
<meta property="og:url" content="http://kevinhqf.github.io/2016/09/22/ViewDetails_03/index.html">
<meta property="og:site_name" content="Kevin's GHB">
<meta property="og:description" content="上一篇的结尾中,我们发现了View的绘制发生在ViewRootImpl的performTraversals()中.而且在其中先后调用了performMeasure(),performLayout(),performDraw().如此一来,我们又有了新的猎物了.就像美食一样,好吃的东西一定要仔细地品尝.在上主菜之前,我们先来点开胃菜.我们先来了解一下Android是怎样绘制View的.(官方的文档H">
<meta property="og:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/viewtree.png">
<meta property="og:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/MeasureState.png">
<meta property="og:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/MeasureSpec.png">
<meta property="og:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/opticalbound.png">
<meta property="og:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/measure.png">
<meta property="og:updated_time" content="2016-09-22T12:36:21.626Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android学习笔记---深入理解View#03">
<meta name="twitter:description" content="上一篇的结尾中,我们发现了View的绘制发生在ViewRootImpl的performTraversals()中.而且在其中先后调用了performMeasure(),performLayout(),performDraw().如此一来,我们又有了新的猎物了.就像美食一样,好吃的东西一定要仔细地品尝.在上主菜之前,我们先来点开胃菜.我们先来了解一下Android是怎样绘制View的.(官方的文档H">
<meta name="twitter:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/viewtree.png">
  
    <link rel="alternate" href="/atom.xml" title="Kevin&#39;s GHB" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kevin&#39;s GHB</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Use your way to change your life</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/kevinhqf" title="Github" target="_blank"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed" target="_blank"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kevinhqf.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-ViewDetails_03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
<a href="/2016/09/22/ViewDetails_03/" class="article-date">
  <time datetime="2016-09-22T12:36:21.630Z" itemprop="datePublished">2016-09-22</time>
</a>


    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android学习笔记---深入理解View#03
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
		
        <p><a href="http://www.jianshu.com/p/f958c9232b07" target="_blank" rel="external">上一篇</a>的结尾中,我们发现了View的绘制发生在<code>ViewRootImpl</code>的<code>performTraversals()</code>中.而且在其中先后调用了<code>performMeasure(),performLayout(),performDraw()</code>.<br>如此一来,我们又有了新的猎物了.就像美食一样,好吃的东西一定要仔细地品尝.在上主菜之前,我们先来点开胃菜.我们先来了解一下Android是怎样绘制View的.(<a href="https://developer.android.com/guide/topics/ui/how-android-draws.html" target="_blank" rel="external">官方的文档How Android Draws Views</a>)</p>
<h3 id="开胃菜-关于View绘制时需要知道的常识"><a href="#开胃菜-关于View绘制时需要知道的常识" class="headerlink" title="开胃菜(关于View绘制时需要知道的常识)"></a>开胃菜(关于View绘制时需要知道的常识)</h3><p>当<code>Activity</code>接受焦点时,就会被要求绘制其布局.虽然<code>Android Framework</code>会处理这个过程,但<code>Activity</code>必须提供整个布局层级的根节点,因为需要知道从哪开始绘制.  </p>
<p><code>Activity</code>的整个布局被转换成了一棵树,绘制整个布局就相当于了遍历整颗树并把每个节点的View绘制出来.相应地,<code>ViewGroup</code>负责要求它的每一个<code>child</code>进行绘制,而<code>View</code>则负责绘制自己.由于树的遍历是有序的,所以父View绘制之前会先绘制其子View,而兄弟节点会按照在树中出现的顺序进行绘制.<br>绘制布局需要进行两个<code>传递过程(pass process)</code>:分别是<code>测量时的传递(measure pass)</code>和<code>布局时的传递(layout pass)</code>.这里所说的传递指的是在<code>view tree</code>的各个节点之间的传递.</p>
<ol>
<li><code>measure pass</code>在<code>measure(int,int)</code>中实现,而且它是一个<strong>从上到下</strong>的传递.在<code>view tree</code>中每个View节点都将它的尺寸规格向下传递给它的孩子,在整个传递过程结束时,每个节点都应该拥有了自己的测量值(尺寸大小).</li>
<li><code>layout pass</code>在<code>layout(int,int,int,int)</code>中发生,它同样也是一个<strong>从上到下</strong>的传递.在传递过程中每个<code>parent</code>都需要根据在<code>measure pass</code>时得到的测量值在布局中放置它的所有<code>children</code>.</li>
</ol>
<p>下面贴上一张普通的<code>view tree</code>的图.<br><img src="http://o7x6n1hmo.bkt.clouddn.com/image/viewtree.png" alt=""><br><a id="more"></a></p>
<p>在<code>measure()</code>函数中,官方定下了一些规则,在函数执行完毕返回前必须要满足下面的条件:</p>
<ol>
<li>View(以及其后代节点)的<code>getMeasuredWidth()(即mMeasuredWidth的值)</code>和<code>getMeasuredHeight()(即mMeasuredHeight的值)</code>的值必须已经设置.从函数名已经知道函数获取的是已经测量的宽高值,<code>measure()</code>函数结束就表明测量结束了,这一条规则理所当然.</li>
<li>View测量后的宽高必须符合其父View所规定的大小.这一条规则可以保证当<code>measure pass</code>结束时,所有的<code>parents</code>能接受其所有<code>children</code>的测量值.这也很好理解,子View的大小总不能比其父布局还大吧,否则就没有意义了.</li>
</ol>
<p>一个为<code>parent</code>的View可能会不止一次地对其<code>children</code>调用<code>measure()</code>.因为如果<code>parent</code>使用未指定的尺寸测量它的每一个<code>child</code>得到各个<code>child</code>想要的大小,但如果所有<code>children</code>的(未加限制的)测量值的总和太大或太小,那就需要<code>parent</code>再次调用<code>measure()</code>重新测量,但这次的测量设置了相应的规则.(举个比喻,就像孩子们在分配糖果时,大家都对所分配的糖果不满意时,父母就会干涉并重新分配)</p>
<h3 id="我要吃神户牛柳-深入measure过程"><a href="#我要吃神户牛柳-深入measure过程" class="headerlink" title="我要吃神户牛柳(深入measure过程)"></a>我要吃神户牛柳(深入<code>measure</code>过程)</h3><p>吃过开胃菜后,再来品尝我们的主菜就会更加的美味.美味的食物通常都有独特的吃法,比如使用特定的餐具.我们的第一道菜(<code>measure</code>)就是神户牛柳,我们需要准备刀叉来用餐.那先准备一下我们的餐具吧.(与<code>measure</code>过程密切相关的两个类).</p>
<h5 id="刀-ViewGroup-LayoutParams"><a href="#刀-ViewGroup-LayoutParams" class="headerlink" title="刀 (ViewGroup.LayoutParams)"></a>刀 (ViewGroup.LayoutParams)</h5><p>先来说明一下<code>ViewGroup.LayoutParams</code>是干什么用的.View通过<code>ViewGroup.LayoutParams</code>来告诉它的<code>parent</code>它在布局中想被放在什么位置和想占多大.而基本的<code>ViewGroup.LayoutParams</code>只能表达View想占多宽和多高,可以通过下面的其中一种方式表达:</p>
<ul>
<li>一个确切的数值大小</li>
<li><code>MATCH_PARENT</code>,表达View想要和它的<code>parent</code>一样大(去掉View的内边距)</li>
<li><code>WRAP_CONTENT</code>,表达View只想要能将它的内容包裹的大小(加上View的内边距)</li>
</ul>
<p><code>ViewGroup.LayoutParams</code>只能表达View大小,但<code>ViewGroup</code>的子类的<code>LayoutParams</code>能表达View的位置.</p>
<h5 id="叉-MeasureSpec"><a href="#叉-MeasureSpec" class="headerlink" title="叉 (MeasureSpec)"></a>叉 (MeasureSpec)</h5><p>看过我的<a href="http://www.jianshu.com/p/f045f57098eb" target="_blank" rel="external">自定义View#02</a>文章的同学可能会对<code>MeasureSpec</code>有所了解.<strong><code>MeasureSpec</code>被<code>parent</code>用来限制<code>child</code>的大小</strong>,在<code>measure()</code>的过程中,它作为参数,从<code>view tree</code>的根节点往下传递到它的子节点和其后代.它有下列3种模式:</p>
<ul>
<li><strong><code>UNSPECIFIED</code></strong>, 这种模式表明<code>parent</code>对它的<code>child</code>的大小没有限制,<code>child</code>可以告诉<code>parent</code>它自己所希望的尺寸.</li>
<li><strong><code>EXACTLY</code></strong>, 这种模式表明<code>parent</code>给<code>child</code>设置了一个确切的值,<code>child</code>必须使用这个值,并且需要保证<code>child</code>的后代节点都要符合这个值的设置</li>
<li><strong><code>AT_MOST</code></strong>, 这种模式表明<code>parent</code>给<code>child</code>设置了一个最大值,<code>child</code>可以是它想要的任何值,但<code>child</code>以及它的后代节点的尺寸大小都必须保证在这个最大值内.</li>
</ul>
<p>既然<code>MeasureSpec</code>有相应的模式来限制View的尺寸,那用什么来表示限制尺寸的大小呢.<code>MeasureSpec</code>采用了一个32位的int值来代表模式和大小,高2位表示模式,低30位表示大小.</p>
<p>有了我们的餐具后,我们可以终于可以开动了.我们先从<code>ViewRootImpl.performTraversals()</code>中调用<code>performMeasure()</code>的地方开始,下面是该部分的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">		<span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123;</span><br><span class="line">                    <span class="comment">// 标注 1</span></span><br><span class="line">                    <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                    <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG, <span class="string">"Ooops, something changed!  mWidth="</span></span><br><span class="line">                            + mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</span><br><span class="line">                            + <span class="string">" mHeight="</span> + mHeight</span><br><span class="line">                            + <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</span><br><span class="line">                            + <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                     <span class="comment">// 标注 2</span></span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Implementation of weights from WindowManager.LayoutParams</span></span><br><span class="line">                    <span class="comment">// We just grow the dimensions as needed and re-measure if</span></span><br><span class="line">                    <span class="comment">// needs be</span></span><br><span class="line">                    <span class="comment">// 标注 3</span></span><br><span class="line">                    <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                    <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                    <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line">					</span><br><span class="line">                    <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                        width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                        childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                        height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">// 标注 4</span></span><br><span class="line">                    <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG,</span><br><span class="line">                                <span class="string">"And hey let's measure once more: width="</span> + width</span><br><span class="line">                                + <span class="string">" height="</span> + height);</span><br><span class="line">                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p>
<p>上面的代码我做了4个标注,我们一个一个来看,先看<code>标注1</code>的代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标注 1</span></span><br><span class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br></pre></td></tr></table></figure></p>
<p>其中这里的<code>mHeight</code>和<code>mWidth</code>分别是窗口(Activity)的宽高,<code>lp</code>为窗口(Window)的布局参数.<code>childWidthMeasureSpec</code>和<code>childHeightMeasureSpec</code>这两个变量其实从<code>标注2</code>的代码就很容易的看出它们是作为参数传进<code>performMeasure(int,int)</code>的.那我们就看看它们代表的是什么意思.  </p>
<p>由于它们是从<code>getRootMeasureSpec(int,int)</code>获取的,从函数名可以看出这个函数是用来获取<code>Root</code>节点的<code>MeasureSpec</code>的(就是根节点在测量时给它的孩子节点所定下的尺寸大小的限制).但我们还是要看看这个函数的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * Figures out the measure spec for the root view in a window based on it's</span><br><span class="line">   * layout params.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> windowSize</span><br><span class="line">   *            The available width or height of the window</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> rootDimension</span><br><span class="line">   *            The layout params for one dimension (width or height) of the</span><br><span class="line">   *            window.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@return</span> The measure spec to use to measure the root view.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> measureSpec;</span><br><span class="line">      <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">          <span class="comment">// Window can't resize. Force root view to be windowSize.</span></span><br><span class="line">          <span class="comment">// 如果布局参数要求MATCH_PARENT,那么就设置为窗口的大小,模式为EXACTLY,因为窗口(Activity)的大小固定</span></span><br><span class="line">          measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">          <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">          <span class="comment">//如果布局参数为WRAP_CONTENT,就设置为AT_MOST模式,最大值为窗口大小</span></span><br><span class="line">          measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">          <span class="comment">// 如果布局的参数为一个确切的值,那我们就让root view为该值,模式为EXACTLY</span></span><br><span class="line">          measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> measureSpec;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getRootMeasureSpec(int,int)</code>的两个参数分别代表窗口的大小(<code>windowSize</code>)和窗口的布局参数的大小(<code>rootDimension</code>).官方的注释(我也做了相应的注释)已经写得很清楚了,这个函数通过window的布局参数来决定<code>root view</code>的<code>MeasureSpec</code>.<br>经过<code>标注1</code>的代码,我们获取到了<code>root tree</code>的根节点的<code>MeasureSpec</code>,这样就可以从树的根节点开始进行测量传递的过程了(在开胃菜中提到的<code>measure pass</code>).在对<code>标注2</code>这个最主要的代码部分进行分析前,我们先来分析后面的<code>标注3</code>和<code>标注4</code>的代码.(好东西肯定要留到最后,反正我是这样想的)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation of weights from WindowManager.LayoutParams</span></span><br><span class="line">               <span class="comment">// We just grow the dimensions as needed and re-measure if</span></span><br><span class="line">               <span class="comment">// needs be</span></span><br><span class="line">               <span class="comment">// 标注 3</span></span><br><span class="line">               <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">               <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">               <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">               <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                   width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                           MeasureSpec.EXACTLY);</span><br><span class="line">                   measureAgain = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                   height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                           MeasureSpec.EXACTLY);</span><br><span class="line">                   measureAgain = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">// 标注 4</span></span><br><span class="line">               <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG,</span><br><span class="line">                           <span class="string">"And hey let's measure once more: width="</span> + width</span><br><span class="line">                           + <span class="string">" height="</span> + height);</span><br><span class="line">                   performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               layoutRequested = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>标注3</code>首先获取到了测量后<code>root view</code>的宽高值,然后分别判断<code>lp.horizontalWeight</code>和<code>lp.verticalWeight</code>的值是否大于0(即我们的布局参数在横向或纵向的<code>weight</code>被设置时,可以理解为在xml布局文件里设置了<code>layout_weight</code>属性).若设置了其中一个方向上的<code>weight</code>,那么<code>标注4</code>的代码都会执行,我们需要再调用一次<code>performMeasure()</code>进行测量(<code>measure pass</code>),但这次采用的是新的参数,把布局参数的<code>weight</code>考虑进去.  </p>
<blockquote>
<p>可能有同学会问,为什么第一次调用<code>performMeasure()</code>前不把<code>weight</code>考虑进去,测量完一次后才考虑这不让前面的工作都白费了吗?我也有相同的疑问,目前我还没找到一个准确的答案,但google这样写一定有它的道理,我在这里分享一下我的想法吧(不一定是正确的,如果错了希望大家能指正).    </p>
<p>我是这样想的:第一次调用<code>performMeasure()</code>的时候并不知道<code>weight</code>是否设置了,因为我们通常设置<code>layout_weight</code>属性都是在子View中设置的,在子View测量完毕前,父布局并不知道它的所有子View的<code>weight</code>属性,而父布局的测量发生在子View测量结束后,所以我们可能需要进行两次的测量传递过程(<code>measure pass</code>).</p>
</blockquote>
<p>好的,清楚了我们<code>标注3,标注4</code>的代码后,我们可以迎接我们的主角<code>performMeasure()</code>了,下面就是<code>performMeasure()</code>的代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>原来代码中调用的是<code>mView.measure(int,int)</code>,即调用了<code>root view</code>的<code>measure()</code>,既然如此,我们来看<code>measure()</code>的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line">    * This is called to find out how big a view should be. The parent</span><br><span class="line">    * supplies constraint information in the width and height parameters.</span><br><span class="line">    * &lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line">    * The actual measurement work of a view is performed in</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125;, called by this method. Therefore, only</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; can and must be overridden by subclasses.</span><br><span class="line">    * &lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the</span><br><span class="line">    *        parent</span><br><span class="line">    * <span class="doctag">@param</span> heightMeasureSpec Vertical space requirements as imposed by the</span><br><span class="line">    *        parent</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@see</span> #onMeasure(int, int)</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">           Insets insets = getOpticalInsets();</span><br><span class="line">           <span class="keyword">int</span> oWidth  = insets.left + insets.right;</span><br><span class="line">           <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</span><br><span class="line">           widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">           heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Suppress sign extension for the low bytes</span></span><br><span class="line">       <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">       <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">               widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">               heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">           mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">           resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</span><br><span class="line">                   mMeasureCache.indexOfKey(key);</span><br><span class="line">           <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">               <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">               onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">               mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">               <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">               setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">               mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></span><br><span class="line">           <span class="comment">// an exception to warn the developer</span></span><br><span class="line">           <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></span><br><span class="line">                       + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></span><br><span class="line">                       + <span class="string">" measured dimension by calling"</span></span><br><span class="line">                       + <span class="string">" setMeasuredDimension()"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">       mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">       mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">               (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>注释中也说了,真正的测量工作是发生在<code>onMeasure(int,int)</code>函数中的,并且说明了View的子类可以并必须重写<code>onMeasure()</code>来测量我们的View.这里的必须并不代表我们在自定义VIew的时候一定要重写<code>onMeasure()</code>,因为<code>onMeasure()</code>已经在View中实现了,在不重写的情况下会调用默认的实现.  </p>
<p>既然注释中给我们指明了方向,那我们就来看看这个<code>onMeasure()</code>.</p>
<h3 id="神户牛的精华-onMeasure"><a href="#神户牛的精华-onMeasure" class="headerlink" title="神户牛的精华(onMeasure)"></a>神户牛的精华(<code>onMeasure</code>)</h3><p><code>onMeasure()</code>可以说是整个<code>measure pass</code>的核心部分,就像是神户牛的精华一样.那现在我们就来感受一下这神户牛的精华所带来的美味.<br>由于在<code>view tree</code>上不可能每个节点都是View节点(这里是叶子节点的意思),就像在<code>&quot;开胃菜&quot;</code>中给大家展现的图一样,在<code>view tree</code>中也会有<code>ViewGroup</code>节点,像<code>FrameLayout,LinearLayout,RelativeLayout...</code>,这些<code>ViewGroup</code>节点都相应的实现了自己的<code>onMeasure()</code>.那么这就说明了<code>ViewGroup.onMeasure()</code>与<code>View.onMeasure()</code>并不一样.既然测量传递的过程(<code>measure pass</code>)是从根节点开始的,那我们也从<code>ViewGroup</code>的<code>onMeasure()</code>开始.这里我们使用的是<code>FrameLayout</code>的代码(其他的<code>ViewGroup</code>大家可以自己试着去分析).</p>
<blockquote>
<p>提示:下面的代码可以先跳过,因为在后面会再提到.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 第1部分</span></span><br><span class="line">       <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">               MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">               MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">       mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">               measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               maxWidth = Math.max(maxWidth,</span><br><span class="line">                       child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">               maxHeight = Math.max(maxHeight,</span><br><span class="line">                       child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">               childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">               <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                           lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                       mMatchParentChildren.add(child);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">	<span class="comment">// 第2部分</span></span><br><span class="line">       <span class="comment">// Account for padding too</span></span><br><span class="line">       maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">       maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Check against our minimum height and width</span></span><br><span class="line">       maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Check against our foreground's minimum height and width</span></span><br><span class="line">       <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">       <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">           maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">           maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">               resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                       childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//第3部分</span></span><br><span class="line">       count = mMatchParentChildren.size();</span><br><span class="line">       <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">               <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">               <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                           - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                           width, MeasureSpec.EXACTLY);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                           getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                           lp.leftMargin + lp.rightMargin,</span><br><span class="line">                           lp.width);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">               <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                           - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                           - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                           height, MeasureSpec.EXACTLY);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                           getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                           lp.topMargin + lp.bottomMargin,</span><br><span class="line">                           lp.height);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>虽然代码不算很长,但为了方便,我们还是将它分为3个部分来分析吧(上面代码注释中所划分的).先来<code>第1部分</code>的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1部分</span></span><br><span class="line">      <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"><span class="comment">// 编号1. 用于判断是否需要对布局参数为MATCH_PARENT的子View进行重新测量</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">              MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">              MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">      mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">          <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">          	<span class="comment">// 编号2. 对每个子View进行测量</span></span><br><span class="line">              measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">              <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">              <span class="comment">// 编号3. 得到所有子View中最大的宽度(加上子View的外边距)</span></span><br><span class="line">              maxWidth = Math.max(maxWidth,</span><br><span class="line">                      child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">              <span class="comment">// 编号4. 得到所有子View中最大的高度(加上子View的外边距)        </span></span><br><span class="line">              maxHeight = Math.max(maxHeight,</span><br><span class="line">                      child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">              <span class="comment">// 编号5. 得到子View的MeasureState</span></span><br><span class="line">              childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">              <span class="comment">// 编号6. 将布局参数为MATCH_PARENT的子View加入到`mMatchParentChildren`集合中</span></span><br><span class="line">              <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                          lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                      mMatchParentChildren.add(child);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了后面的分析方便,我在上面的代码注释中都给相应的语句进行了编号,我们先来分析简单的.<br><code>编号1</code>的<code>measureMatchParentChildren</code>是用于判断FrameLayout是否需要对布局参数为<code>MATCH_PARENT</code>的子View进行第二次测量.这里我们等分析过<code>编号2</code>的代码后再对这个变量进行解析(这里可以先留个疑问).<br>而<code>编号3,编号4</code>的代码就是为了得到<code>FrameLayout</code>所有孩子中测量后的最大宽高(加上边距),因为FrameLayout需要按照它的孩子中尺寸最大的宽高进行测量.<br><code>编号5</code>的代码就是为了得到子View的<code>MeasuredState</code>,这个对我们来说是个新的概念.既然这样,我们就来看看<code>child.getMeasuredState()</code>这个在<code>View</code>类下的函数是个怎样的函数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Return only the state bits of &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125;</span><br><span class="line">    * and &#123;<span class="doctag">@link</span> #getMeasuredHeightAndState()&#125;, combined into one integer.</span><br><span class="line">    * The width component is in the regular bits &#123;<span class="doctag">@link</span> #MEASURED_STATE_MASK&#125;</span><br><span class="line">    * and the height component is at the shifted bits</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #MEASURED_HEIGHT_STATE_SHIFT&#125;&gt;&gt;&#123;<span class="doctag">@link</span> #MEASURED_STATE_MASK&#125;.</span><br><span class="line">    */</span></span><br><span class="line">    <span class="comment">// 将宽高的状态位结合成在一个32位的int值并返回</span></span><br><span class="line">    <span class="comment">// 宽度的状态位在常规的位置</span></span><br><span class="line">    <span class="comment">// 高度的状态位在偏移后的位置</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (mMeasuredWidth&amp;MEASURED_STATE_MASK)</span><br><span class="line">               | ((mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)</span><br><span class="line">                       &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用于使高度的状态位偏移的位数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MEASURED_HEIGHT_STATE_SHIFT = <span class="number">16</span>;</span><br></pre></td></tr></table></figure></p>
<p>我把用到的变量也贴在了上面的代码中.首先我们来了解一下什么是”宽高的状态位”.我们知道<code>mMeasuredHeight</code>或<code>mMeasuredWidth</code>都是32位的int值,但这个值并不是一个表示宽高的实际大小的值,而是一个由宽高的状态和实际大小所组合的值.这里的高8位就表示状态(<code>STATE</code>),而低24位表示的是实际的尺寸大小(<code>SIZE</code>),这个信息可以从它们相应的掩码看出.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于得出宽高的状态位的掩码</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MEASURED_STATE_MASK = <span class="number">0xff000000</span>;</span><br><span class="line">   <span class="comment">// 用于得出宽高的尺寸位的掩码</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MEASURED_SIZE_MASK = <span class="number">0x00ffffff</span>;</span><br></pre></td></tr></table></figure></p>
<p>这就解析了为什么我们的<code>getMeasuredHeight()</code>函数返回的是<code>mMeasuredHeight &amp; MEASURED_SIZE_MASK</code>.而<code>getMeasuredHeightAndState()</code>返回的是<code>mMeasuredHeight</code>.相应的关于宽度的函数也是一个道理.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mMeasuredHeight &amp; MEASURED_SIZE_MASK;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredHeightAndState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mMeasuredHeight;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们再来看<code>getMeasuredState()</code>是怎样将宽高的状态位组合在一个int值中的.首先<code>mMeasuredWidth &amp; MEASURED_STATE_MASK</code>得到了宽度的状态位,保存在高8位.然后通过<code>(mMeasuredHeight &gt;&gt; MEASURED_HEIGHT_STATE_SHIFT)</code>和<code>(MEASURED_STATE_MASK &gt;&gt; MEASURED_HEIGHT_STATE_SHIFT)</code>将高度和状态掩码都右移了16位,现在高度的状态位在第8到第15位上,而<code>MEASURED_STATE_MASK</code>变成了<code>0x0000ff00</code>,接着将两个移位后的数进行按位相与(<code>&amp;</code>)得到了高度的状态位,保存在8-15位上.最后将处理后宽度和高度按位相或(<code>|</code>)得到一个保存了宽度和高度的状态位的int值.如下图.<br><img src="http://o7x6n1hmo.bkt.clouddn.com/image/MeasureState.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Merge two states as returned by &#123;<span class="doctag">@link</span> #getMeasuredState()&#125;.</span><br><span class="line">    * <span class="doctag">@param</span> curState The current state as returned from a view or the result</span><br><span class="line">    * of combining multiple views.</span><br><span class="line">    * <span class="doctag">@param</span> newState The new view state to combine.</span><br><span class="line">    * <span class="doctag">@return</span> Returns a new integer reflecting the combination of the two</span><br><span class="line">    * states.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">combineMeasuredStates</span><span class="params">(<span class="keyword">int</span> curState, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> curState | newState;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>回到<code>编号5</code>的代码,就是为了将所有子View的<code>state</code>都结合在一起,这个有什么作用现在也不好讲.先继续看吧.</p>
<p><code>编号2</code>的代码是将<code>FrameLayout</code>中所有<code>visibility</code>属性不为<code>GONE</code>的子View都进行测量(即在布局中占据位置的View),使用的是<code>measureChildWithMargins()</code>.下面我们来看这个函数的代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Ask one of the children of this view to measure itself, taking into</span><br><span class="line">    * account both the MeasureSpec requirements for this view and its padding</span><br><span class="line">    * and margins. The child must have MarginLayoutParams The heavy lifting is</span><br><span class="line">    * done in getChildMeasureSpec.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> child The child to measure (需要测量的子View)</span><br><span class="line">    * <span class="doctag">@param</span> parentWidthMeasureSpec The width requirements for this view </span><br><span class="line">    *		(parent对子View宽度的要求(MeasureSpec))</span><br><span class="line">    * <span class="doctag">@param</span> widthUsed Extra space that has been used up by the parent</span><br><span class="line">    *        horizontally (possibly by other children of the parent)</span><br><span class="line">    *        (被parent或其他兄弟节点在布局的水平方向上使用了的尺寸大小)</span><br><span class="line">    * <span class="doctag">@param</span> parentHeightMeasureSpec The height requirements for this view</span><br><span class="line">    * 		(parent对子View高度的要求(MeasureSpec))</span><br><span class="line">    * <span class="doctag">@param</span> heightUsed Extra space that has been used up by the parent</span><br><span class="line">    *        vertically (possibly by other children of the parent)</span><br><span class="line">    *        (被parent或其他兄弟节点在布局的垂直方向上使用了的尺寸大小)</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span><br><span class="line">           <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span><br><span class="line">           <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                       + widthUsed, lp.width);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                       + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>像代码中的注释所写的一样,这个函数就是用来告诉<code>child</code>需要进行测量.测量过程中需要遵循<code>parent</code>的<code>MeasureSpec</code>,还需要考虑将<code>padding</code>和<code>margin</code>的值.通过了<code>getChildMeasureSpec()</code>得到了子View的<code>MeasureSpec</code>后就可以调用子View的<code>measure()</code>进行测量了.所以我们要来看看<code>getChildMeasureSpec(int,int,int)</code>这个函数,先来看看函数原型的文档,因为我们要先搞清楚各个参数所代表的意义.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Does the hard part of measureChildren: figuring out the MeasureSpec to</span><br><span class="line">    * pass to a particular child. This method figures out the right MeasureSpec</span><br><span class="line">    * for one dimension (height or width) of one child view.</span><br><span class="line">    *</span><br><span class="line">    * The goal is to combine information from our MeasureSpec with the</span><br><span class="line">    * LayoutParams of the child to get the best possible results. For example,</span><br><span class="line">    * if the this view knows its size (because its MeasureSpec has a mode of</span><br><span class="line">    * EXACTLY), and the child has indicated in its LayoutParams that it wants</span><br><span class="line">    * to be the same size as the parent, the parent should ask the child to</span><br><span class="line">    * layout given an exact size.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> spec The requirements for this view</span><br><span class="line">    * 		(对View的尺寸限制MeasureSpec)</span><br><span class="line">    * <span class="doctag">@param</span> padding The padding of this view for the current dimension and</span><br><span class="line">    *        margins, if applicable</span><br><span class="line">    *        (可以理解为父布局的padding值+View的margin值,即父布局中未使用的尺寸大小)</span><br><span class="line">    * <span class="doctag">@param</span> childDimension How big the child wants to be in the current</span><br><span class="line">    *        dimension</span><br><span class="line">    *        (View希望在布局中的大小,即子View布局参数的宽高)</span><br><span class="line">    * <span class="doctag">@return</span> a MeasureSpec integer for the child</span><br><span class="line">    * </span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个函数是为了获得当前View的<code>MeasureSpec</code>以便于进行测量和传递给子View的.函数中主要是根据父布局的<code>MeasureSpec</code>来创建View自己的<code>MeasureView</code>.下面是相应的代码.</p>
<blockquote>
<p>代码有点长,希望能完整地看一遍.但如果不想看也不要紧,就粗略地扫一眼吧.因为后面有图片进行总结,正所谓一图胜千言啊!</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 分别获取父布局`MeasureSpec`中的模式和尺寸</span></span><br><span class="line">       <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">       <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line">	<span class="comment">// 获取父布局实际提供给View的尺寸大小(去除边距)</span></span><br><span class="line">       <span class="comment">// 即父布局最大的可用的大小</span></span><br><span class="line">       <span class="comment">// 与0相比取最大值,以免尺寸大小为负值</span></span><br><span class="line">       <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">// 当前View最终的尺寸大小和模式</span></span><br><span class="line">       <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">	<span class="comment">// 根据父布局的模式来决定View的模式和尺寸</span></span><br><span class="line">       <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">       <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">       <span class="comment">// 表示父布局的大小为确切的值</span></span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">       	<span class="comment">// 由于`MATCH_PARENT`=-1,`WRAP_CONTENT`=-2,</span></span><br><span class="line">           <span class="comment">// 所以childDimension &gt;= 0 表示View的宽高布局参数为具体的值</span></span><br><span class="line">           <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               resultSize = childDimension;</span><br><span class="line">               resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">           	<span class="comment">// 表示View的布局参数为`MATCH_PARENT`,即View希望大小是父布局的最大的可以大小</span></span><br><span class="line">               <span class="comment">// 模式与父布局一样为EXACTLY</span></span><br><span class="line">               <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">               resultSize = size;</span><br><span class="line">               resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">               <span class="comment">// bigger than us.</span></span><br><span class="line">               <span class="comment">// 表示View的布局参数为`WRAP_CONTENT`,那么说明View的大小不明确,需要由它的内容决定</span></span><br><span class="line">               <span class="comment">// 所以测量值的尺寸为父布局的最大的可以大小,模式为AT_MOST</span></span><br><span class="line">               resultSize = size;</span><br><span class="line">               resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">       <span class="comment">// 表示父布局的大小不确定,需要由父布局的内容决定</span></span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">           <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">               <span class="comment">// 表明View的布局大小为确切的值</span></span><br><span class="line">               <span class="comment">// 所以View的测量大小为布局参数的值,模式为EXACTLY</span></span><br><span class="line">               resultSize = childDimension;</span><br><span class="line">               resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">               <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">               <span class="comment">// 表明View的布局参数为MATCH_PARENT</span></span><br><span class="line">               <span class="comment">// 所以View的测量大小为父布局的可用大小,模式与父布局一样为AT_MOST</span></span><br><span class="line">               resultSize = size;</span><br><span class="line">               resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">               <span class="comment">// bigger than us.</span></span><br><span class="line">               <span class="comment">// View的布局参数为WRAP_CONTENT,即View的测量尺寸大小不确定,由其内容决定</span></span><br><span class="line">               <span class="comment">// 所以View的测量大小为父布局最大的可以大小,模式为AT_MOST</span></span><br><span class="line">               resultSize = size;</span><br><span class="line">               resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">       <span class="comment">// 表示父布局对View的大小没有限制,通常用在ListView等可滚动的控件中</span></span><br><span class="line">       <span class="comment">// 这种情况下父布局会满足View的所有要求</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">           <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">               resultSize = childDimension;</span><br><span class="line">               resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">               <span class="comment">// be</span></span><br><span class="line">               resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">               resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">               <span class="comment">// big it should be</span></span><br><span class="line">               resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">               resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据最终的View的模式和尺寸生成View的MeasureSpec</span></span><br><span class="line">       <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>虽然上面的代码不短,但代码逻辑并不复杂,而且我已经在代码上做了比较明白的注释了,如果还是不理解,那就请看图.<br><img src="http://o7x6n1hmo.bkt.clouddn.com/image/MeasureSpec.png" alt=""><br>函数的功能就是为了给View生成一个<code>MeasureSpec</code>类型的int,而这个值是由模式和大小合成的,而且它们的值由父布局<code>MeasureSpec</code>的模式和View的布局大小共同决定.上图就是一个决定View的<code>Mode</code>和<code>Size</code>的过程.<br>这里有一点需要注意的,就是当父布局的<code>MeasureSpec</code>的模式为<code>UNSPECIFIED</code>时,若View的布局大小不为一个具体的值那么<code>resultSize</code>的大小就为0.这里决定<code>resultSize</code>的值是下面的一条语句.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br></pre></td></tr></table></figure></p>
<p>而这里的<code>View.sUseZeroUnspecifiedMeasureSpec</code>可以在View中找到相应的信息.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Always return a size of 0 for MeasureSpec values with a mode of UNSPECIFIED</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">boolean</span> sUseZeroUnspecifiedMeasureSpec = <span class="keyword">false</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">   .....</span><br><span class="line">   		<span class="comment">// In M and newer, our widgets can pass a "hint" value in the size</span></span><br><span class="line">           <span class="comment">// for UNSPECIFIED MeasureSpecs. This lets child views of scrolling containers</span></span><br><span class="line">           <span class="comment">// know what the expected parent size is going to be, so e.g. list items can size</span></span><br><span class="line">           <span class="comment">// themselves at 1/3 the size of their container. It breaks older apps though,</span></span><br><span class="line">           <span class="comment">// specifically apps that use some popular open source libraries.</span></span><br><span class="line">           sUseZeroUnspecifiedMeasureSpec = targetSdkVersion &lt; M;</span><br><span class="line">   ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>就是说若当前的Android版本小于<code>M</code>的话那<code>sUseZeroUnspecifiedMeasureSpec</code>的值就为<code>true</code>.所以在旧版本的Android中,<code>resultSize</code>的值都为0.<br>现在我们回到<code>编号1</code>的地方就可能对那句代码有所理解了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编号1. 用于判断是否需要对布局参数为MATCH_PARENT的子View进行重新测量</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">              MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">              MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br></pre></td></tr></table></figure></p>
<p>我们现在对应着上面的View的<code>MeasureSpec</code>生成图来分析代码.将流程反过来看,即从有编号的框开始看,我们可以看到在<code>(1),(2),(4),(7)</code>4种情况下<code>resultMode</code>的值为<code>EXACTLY</code>.而它们的条件有3种是<code>childDimension &gt;= 0</code>即FrameLayout的布局参数<code>layout_width</code>或<code>layout_height</code>为实际的具体值.另一种情况就是FramLayout的布局参数为<code>MATCH_PARENT</code>且它的父布局为<code>EXACTLY</code>.  综合的来讲可以这么理解吧就是当FrameLayout的布局宽高不同时设置为具体的值,或不同时为<code>MATCH_PARENT</code>那么<code>measureMatchParentChildren</code>这个值就为<code>true</code>.<br>再简单的讲就是如果FrameLayout的宽高只要有一个设置为<code>WRAP_CONTENT</code>,那么该值就为<code>true</code>.那么就需要对布局参数为<code>MATCH_PARENT</code>的子View进行重新测量.因为<code>WRAP_CONTENT</code>的情况下父布局的测量值受子View的影响.</p>
<p>能看到这里的同学真是不简单啊,没想到<code>第1部分</code>讲了这么久,(有的同学就可能会说:这分”神户牛柳”的量也太多了吧,吃得有点撑啊!)这里篇幅确实有点长,但如果仔细看下来的话还是能学到不少的东西.大家可以先休息一下,待会再来继续阅读.我也在下面做了分割线帮大家标记位置.</p>
<hr>
<h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><p>我们来继续我们<code>onMeasure()</code>的<code>第2部分</code>代码的分析吧.相信我,当你看完<code>第1部分</code>的分析后,后面就会很有感觉.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第2部分</span></span><br><span class="line"><span class="comment">// 前面我们的maxWidth和maxHeight只是计算了子View的外边距</span></span><br><span class="line">      <span class="comment">// 但没有计算FrameLayout的内边距,所以在这里加上</span></span><br><span class="line">      maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">      maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check against our minimum height and width</span></span><br><span class="line">      <span class="comment">// 保证我们的`maxWidth`和`maxHeight`不会太小(至少要等于最小的建议值)</span></span><br><span class="line">      <span class="comment">// 这里的最少建议值与背景有关</span></span><br><span class="line">      maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">      maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check against our foreground's minimum height and width</span></span><br><span class="line">      <span class="comment">// 上面保证了背景的宽高值,下面保证前景对的宽高值</span></span><br><span class="line">      <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">      <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">          maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">          maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标注</span></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">              resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                      childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br></pre></td></tr></table></figure></p>
<p><code>第2部分</code>的代码是先是确定了<code>maxWidth</code>和<code>maxHeight</code>的值,给大家看一眼<code>getSuggestedMinimumHeight()</code>的代码吧,因为后面这个函数还会用到,我相信大家很容易就能理解.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们主要还是看<code>标注</code>的那句代码,<code>setMeasuredDimension()</code>就是将测量好的宽高值存储下来供后面的布局过程使用.来看看代码吧.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * &lt;p&gt;This method must be called by &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; to store the</span><br><span class="line">    * measured width and measured height. Failing to do so will trigger an</span><br><span class="line">    * exception at measurement time.&lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> measuredWidth The measured width of this view.  May be a complex</span><br><span class="line">    * bit mask as defined by &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125; and</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #MEASURED_STATE_TOO_SMALL&#125;.</span><br><span class="line">    * <span class="doctag">@param</span> measuredHeight The measured height of this view.  May be a complex</span><br><span class="line">    * bit mask as defined by &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125; and</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #MEASURED_STATE_TOO_SMALL&#125;.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">           Insets insets = getOpticalInsets();</span><br><span class="line">           <span class="keyword">int</span> opticalWidth  = insets.left + insets.right;</span><br><span class="line">           <span class="keyword">int</span> opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">           measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">           measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">       &#125;</span><br><span class="line">       setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Sets the measured dimension without extra processing for things like optical bounds.</span><br><span class="line">    * Useful for reapplying consistent values that have already been cooked with adjustments</span><br><span class="line">    * for optical bounds, etc. such as those from the measurement cache.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> measuredWidth The measured width of this view.  May be a complex</span><br><span class="line">    * bit mask as defined by &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125; and</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #MEASURED_STATE_TOO_SMALL&#125;.</span><br><span class="line">    * <span class="doctag">@param</span> measuredHeight The measured height of this view.  May be a complex</span><br><span class="line">    * bit mask as defined by &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125; and</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #MEASURED_STATE_TOO_SMALL&#125;.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">       mMeasuredWidth = measuredWidth;</span><br><span class="line">       mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">       mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面就是相关的代码,也比较简单,<code>setMeasuredDimension()</code>中最后调用了<code>setMeasuredDimensionRaw()</code>来设置<code>mMeasuredWidth</code>与<code>mMeasuredHeight</code>的值.其中关于<code>Optical Bounds</code>有兴趣的同学可以到Internet上搜索一下,或看看下图.这里我们不作讨论,可以跳过.<br><img src="http://o7x6n1hmo.bkt.clouddn.com/image/opticalbound.png" alt=""><br>了解了<code>setMeasuredDimension()</code>后,那我们再来看看调用处给它传进的两个参数<code>resolveSizeAndState(maxWidth, widthMeasureSpec, childState)</code>和<code>resolveSizeAndState(maxWidth, widthMeasureSpec, childState)</code>.既然调用了<code>resolveSizeAndState()</code>,那就看看它的代码吧.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Utility to reconcile a desired size and state, with constraints imposed</span><br><span class="line">    * by a MeasureSpec. Will take the desired size, unless a different size</span><br><span class="line">    * is imposed by the constraints. The returned value is a compound integer,</span><br><span class="line">    * with the resolved size in the &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125; bits and</span><br><span class="line">    * optionally the bit &#123;<span class="doctag">@link</span> #MEASURED_STATE_TOO_SMALL&#125; set if the</span><br><span class="line">    * resulting size is smaller than the size the view wants to be.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> size How big the view wants to be.</span><br><span class="line">    * <span class="doctag">@param</span> measureSpec Constraints imposed by the parent.</span><br><span class="line">    * <span class="doctag">@param</span> childMeasuredState Size information bit mask for the view's</span><br><span class="line">    *                           children.</span><br><span class="line">    * <span class="doctag">@return</span> Size information bit mask as defined by</span><br><span class="line">    *         &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125; and</span><br><span class="line">    *         &#123;<span class="doctag">@link</span> #MEASURED_STATE_TOO_SMALL&#125;.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">       <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">               <span class="keyword">if</span> (specSize &lt; size) &#123;</span><br><span class="line">               	<span class="comment">// 防止View超出了限制的大小所做的处理</span></span><br><span class="line">                   result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   result = size;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">               result = specSize;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               result = size;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将尺寸大小值和状态组合到一起</span></span><br><span class="line">       <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>第1部分</code>我们已经读过了不少的类似的代码了,在这里我就不啰嗦了.主要还是讲讲<code>resolveSizeAndState(maxHeight, heightMeasureSpec,childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)</code>这句代码吧,为什么这里需要进行左移?如果前面有认真看的话就很容易理解,因为我们的<code>childState</code>是存有宽高的状态的组合值,我们的高度的状态值存在第8-15位,所以这里需要将它左移16位(将状态位放置在常规的位置).</p>
<h4 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h4><p>来到<code>第3部分</code>了,这部分比较简单,我们先来看看代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第3部分</span></span><br><span class="line">      count = mMatchParentChildren.size();</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">              <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">              <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">              <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              	<span class="comment">// 宽度为总宽度减去父布局的Padding和View的Margin</span></span><br><span class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                          - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                          - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                  childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                          width, MeasureSpec.EXACTLY);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 第1部分已经讨论过</span></span><br><span class="line">                  childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                          getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                          lp.leftMargin + lp.rightMargin,</span><br><span class="line">                          lp.width);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">              <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                          - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                          - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                  childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                          height, MeasureSpec.EXACTLY);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                          getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                          lp.topMargin + lp.bottomMargin,</span><br><span class="line">                          lp.height);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的代码就是当FrameLayout有多于1个的子View的布局宽高为<code>MATCH_PARENT</code>时(并且满足<code>第1部分</code>中的<code>measureMatchParentChildren</code>为<code>true</code>),即当FrameLayout的宽高设置存在<code>WRAP_CONTENT</code>时,对子View进行重新的测量.</p>
<h4 id="View的onMeasure"><a href="#View的onMeasure" class="headerlink" title="View的onMeasure()"></a>View的onMeasure()</h4><p>到这里我们<code>FrameLayout</code>的<code>onMeasure()</code>已经分析完毕了,既然我们已经分析过了<code>ViewGroup</code>的<code>onMeasure()</code>,那<code>View</code>的<code>onMeasure()</code>我觉得也免不了,废话不说赶紧上菜.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">               getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码还是很简单的,就一句.虽然嵌套很多,但只有一个函数我们没有见过,就是<code>getDefaultSize()</code>,那就看看它是何方神圣.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Utility to return a default size. Uses the supplied size if the</span><br><span class="line">    * MeasureSpec imposed no constraints. Will get larger if allowed</span><br><span class="line">    * by the MeasureSpec.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> size Default size for this view</span><br><span class="line">    * <span class="doctag">@param</span> measureSpec Constraints imposed by the parent</span><br><span class="line">    * <span class="doctag">@return</span> The size this view should be.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = size;</span><br><span class="line">       <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">       <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">           result = size;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">           result = specSize;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数是决定View的<code>MeasureSpec</code>的<code>Size</code>的一种默认的方法.代码非常的简单,我就不再多说了.因为今天看这种代码看得真的不少,我相信很多同学都快要看吐了.<br>不过到这里我很开心,因为我们这次的任务完成了,<code>measure</code>的过程我们已经分析完了.</p>
<h3 id="最后的甜点-总结"><a href="#最后的甜点-总结" class="headerlink" title="最后的甜点(总结)"></a>最后的甜点(总结)</h3><p>牛柳吃完了,不知道大家能不能消化,所以最后给大家上个甜点吧.最后还是用图说话,来总结一下<code>measure</code>的整个流程.<br><img src="http://o7x6n1hmo.bkt.clouddn.com/image/measure.png" alt="measure"></p>

      
    </div>
    <footer class="article-footer">
	  
	  <a data-url="http://kevinhqf.github.io/2016/09/22/ViewDetails_03/" data-id="citec0q8900111x86lpkq4wjj" data_title="Android学习笔记---深入理解View#03" data_summary="上一篇的结尾中,我们发现了View的绘制发生在View..." class="article-share-link">Share</a>
      
        <a href="http://kevinhqf.github.io/2016/09/22/ViewDetails_03/#disqus_thread" class="article-comment-link">Comments</a>
      

      
	  
      
	  
<span>
Updated:<time datetime="2016-09-22T12:36:21.626Z" itemprop="dateModified">2016-09-22</time>
</span>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/09/20/ViewDetails_02/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android学习笔记---深入理解View#02</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



</section>
        
          
  <div id="toc" class="toc-aside">
  <h2 class="toc-title">Contents</h2>
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#开胃菜-关于View绘制时需要知道的常识"><span class="toc-number">1.</span> <span class="toc-text">开胃菜(关于View绘制时需要知道的常识)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我要吃神户牛柳-深入measure过程"><span class="toc-number">2.</span> <span class="toc-text">我要吃神户牛柳(深入measure过程)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#刀-ViewGroup-LayoutParams"><span class="toc-number">2.0.1.</span> <span class="toc-text">刀 (ViewGroup.LayoutParams)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#叉-MeasureSpec"><span class="toc-number">2.0.2.</span> <span class="toc-text">叉 (MeasureSpec)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#神户牛的精华-onMeasure"><span class="toc-number">3.</span> <span class="toc-text">神户牛的精华(onMeasure)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Part-1"><span class="toc-number">3.1.</span> <span class="toc-text">Part 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part-2"><span class="toc-number">3.2.</span> <span class="toc-text">Part 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part-3"><span class="toc-number">3.3.</span> <span class="toc-text">Part 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View的onMeasure"><span class="toc-number">3.4.</span> <span class="toc-text">View的onMeasure()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最后的甜点-总结"><span class="toc-number">4.</span> <span class="toc-text">最后的甜点(总结)</span></a></li></ol>
    
  </div>

<aside id="sidebar">

  
    
<div class="widget-wrap">
  <h3 class="widget-title">ABOUT ME</h3>
  <ul class="widget about-me">
    
    <li><img class="author" title="About me" src="/images/avatar.jpg" /></li>
    
    
    <li>Hi,I'm Kevin.</li>
    
  </ul>
</div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">Markdown</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/22/ViewDetails_03/">Android学习笔记---深入理解View#03</a>
          </li>
        
          <li>
            <a href="/2016/09/20/ViewDetails_02/">Android学习笔记---深入理解View#02</a>
          </li>
        
          <li>
            <a href="/2016/09/17/ViewDetails_01/">Android学习笔记---深入理解View#01</a>
          </li>
        
          <li>
            <a href="/2016/09/14/CustomView-custom_drawing/">Android学习笔记---重新学习自定义View#02</a>
          </li>
        
          <li>
            <a href="/2016/09/12/CustomView-create_view/">Android学习笔记---重新学习自定义View#01</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    

  

</aside>

        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Kevin HO<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/howiefh/hexo-theme-landscape-f" target="_blank" title="Landscape-F">Landscape-F</a>
    
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'kevinhqf';
  
  var disqus_url = 'http://kevinhqf.github.io/2016/09/22/ViewDetails_03/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>






<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<div class="bottom-btn">

	<a class="icon-gotop" href="javascript:void(0)" title="返回顶部"></a>
	<script src="/js/gotop.js"></script>
	<!--
	<script src="/js/gotop.js"></script>
	-->


	<a class="icon-toc-toggle" href="javascript:void(0)" title="文章目录"></a>
	<!--
	<script src="/js/toc_aside_toggle.js"></script>
	-->

</div>
<script src="/js/toc_aside_toggle.js"></script>


<script src="/js/script.js"></script>







  </div>
</body>
</html>
