<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android学习笔记---深入理解View#04 | Kevin&#39;s GHB</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上次我们对View的测量过程有了了解，接着这次肯定就是要沿着View的3大流程往下走。我们本次的主角就是View的Layout过程。
从performLayout()开始出发我们的已经知道了View的布局过程layout pass就是从performLayout()开始的，那么我们就先来大概的浏览一下这个函数的代码。

TIP: 这里我们先简略的浏览整个函数的代码(不用认真看)，后面我们会将代码分">
<meta property="og:type" content="article">
<meta property="og:title" content="Android学习笔记---深入理解View#04">
<meta property="og:url" content="http://kevinhqf.github.io/2016/09/26/ViewDetails_04/index.html">
<meta property="og:site_name" content="Kevin's GHB">
<meta property="og:description" content="上次我们对View的测量过程有了了解，接着这次肯定就是要沿着View的3大流程往下走。我们本次的主角就是View的Layout过程。
从performLayout()开始出发我们的已经知道了View的布局过程layout pass就是从performLayout()开始的，那么我们就先来大概的浏览一下这个函数的代码。

TIP: 这里我们先简略的浏览整个函数的代码(不用认真看)，后面我们会将代码分">
<meta property="og:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/position.png">
<meta property="og:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/layout_pass.png">
<meta property="og:updated_time" content="2016-09-26T15:00:29.713Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android学习笔记---深入理解View#04">
<meta name="twitter:description" content="上次我们对View的测量过程有了了解，接着这次肯定就是要沿着View的3大流程往下走。我们本次的主角就是View的Layout过程。
从performLayout()开始出发我们的已经知道了View的布局过程layout pass就是从performLayout()开始的，那么我们就先来大概的浏览一下这个函数的代码。

TIP: 这里我们先简略的浏览整个函数的代码(不用认真看)，后面我们会将代码分">
<meta name="twitter:image" content="http://o7x6n1hmo.bkt.clouddn.com/image/position.png">
  
    <link rel="alternate" href="/atom.xml" title="Kevin&#39;s GHB" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kevin&#39;s GHB</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Use your way to change your life</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/kevinhqf" title="Github" target="_blank"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed" target="_blank"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kevinhqf.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-ViewDetails_04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
<a href="/2016/09/26/ViewDetails_04/" class="article-date">
  <time datetime="2016-09-26T15:00:29.717Z" itemprop="datePublished">2016-09-26</time>
</a>


    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android学习笔记---深入理解View#04
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
		
        <p><a href="http://www.jianshu.com/p/d85c3e06a3e1" target="_blank" rel="external">上次</a>我们对View的测量过程有了了解，接着这次肯定就是要沿着View的3大流程往下走。我们本次的主角就是View的<code>Layout</code>过程。</p>
<h3 id="从performLayout-开始出发"><a href="#从performLayout-开始出发" class="headerlink" title="从performLayout()开始出发"></a>从<code>performLayout()</code>开始出发</h3><p>我们的已经知道了View的布局过程<code>layout pass</code>就是从<code>performLayout()</code>开始的，那么我们就先来大概的浏览一下这个函数的代码。</p>
<blockquote>
<p>TIP: 这里我们先简略的浏览整个函数的代码(不用认真看)，后面我们会将代码分开几个部分，一个部分一个部分的进行分析。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span><br><span class="line">            <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将当前是否有布局请求的flag设置为false</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">       </span><br><span class="line">        mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 将当前正在布局的flag设置为true</span></span><br><span class="line">        mInLayout = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 获取decorView</span></span><br><span class="line">        <span class="keyword">final</span> View host = mView;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Laying out "</span> + host + <span class="string">" to ("</span> +</span><br><span class="line">                    host.getMeasuredWidth() + <span class="string">", "</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"layout"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 对decorView进行布局</span></span><br><span class="line">            host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">			<span class="comment">// 将当前正在布局的flag设置为false</span></span><br><span class="line">            mInLayout = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 获取当前请求布局的View的个数</span></span><br><span class="line">            <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">            <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// requestLayout() was called during layout.</span></span><br><span class="line">                <span class="comment">// If no layout-request flags are set on the requesting views, there is no problem.</span></span><br><span class="line">                <span class="comment">// If some requests are still pending, then we need to clear those flags and do</span></span><br><span class="line">                <span class="comment">// a full request/measure/layout pass to handle this situation.</span></span><br><span class="line">                <span class="comment">// 获取需要进行布局的View</span></span><br><span class="line">                ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Set this flag to indicate that any further requests are happening during</span></span><br><span class="line">                    <span class="comment">// the second pass, which may result in posting those requests to the next</span></span><br><span class="line">                    <span class="comment">// frame instead</span></span><br><span class="line">                    <span class="comment">// 设置正在处理布局请求的flag为true</span></span><br><span class="line">                    mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Process fresh layout requests, then measure and layout</span></span><br><span class="line">                    <span class="comment">// 获取需要进行布局的View的个数</span></span><br><span class="line">                    <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                        <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                        Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                <span class="string">" during layout: running second layout pass"</span>);</span><br><span class="line">                        view.requestLayout();</span><br><span class="line">                    &#125;</span><br><span class="line">                    measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                    mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                    host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                    mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Check the valid requests again, this time without checking/clearing the</span></span><br><span class="line">                    <span class="comment">// layout flags, since requests happening during the second pass get noop'd</span></span><br><span class="line">                    validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                        <span class="comment">// Post second-pass requests to the next frame</span></span><br><span class="line">                        getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                    <span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                                    Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                            <span class="string">" during second layout pass: posting in next frame"</span>);</span><br><span class="line">                                    view.requestLayout();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>performLayout()</code>的代码仔细看起来也并不难，我们一点一点的来进行分析。我们都知道这个函数是在<code>ViewRootImpl</code>的<code>performTravers()</code>进行调用的。那我们来看看它的传入参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br></pre></td></tr></table></figure></p>
<p>分别是当前的窗口布局参数<code>lp</code>，窗口的宽度和高度<code>desiredWindowWidth,desiredWindowHeight</code>。<br>既然知道了参数的意义,那我们就可以对<code>performLayout()</code>进行分析了。首先我们就来分析下面部分的代码（为了看起来更加的清晰,我将一些无关的代码去掉了，去掉的部分我用省略号代替）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span><br><span class="line">            <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        mInLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> View host = mView;</span><br><span class="line">       ........</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">            mInLayout = <span class="keyword">false</span>;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<p>这里我们可以看到首先是设置了<code>mInLayout = true</code>，表示当前正在布局的过程当中。随后<code>final View host = mView</code>获取了我们的<code>decorView</code>，然后就调用了我们<code>host.layout()</code>对我们的<code>decorView</code>进行布局。布局完成后就将我们的<code>mInLayout</code>设置为<code>false</code>表示当前不在布局过程中。这里我们需要关心的就只有<code>host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight())</code>这句代码，但这并不急于一时，我们先将<code>performLayout()</code>整个函数的逻辑分析清楚后再对里面的内容进行深入。<br>那么我们就接着看<code>performLayout()</code>的下面的代码（和上面一样的,我只保留了关键的代码）：</p>
<blockquote>
<p>Tip：下面的代码可以先简略的扫一眼，后面我会详细的分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line"><span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">        	<span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">            view.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);            </span><br><span class="line">        mInLayout = <span class="keyword">true</span>;</span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">		mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line">		validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">            getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            	<span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                	<span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    	<span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                        ......... </span><br><span class="line">                        view.requestLayout();</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">..........</span><br><span class="line">mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有个地方让我非常的在意，就是<code>mLayoutRequesters</code>这个属性变量，因为后面有几次都用到了这个变量。这是一个<code>ArrayList&lt;View&gt;</code>类型的一个集合，从变量名来看，这应该是一个存放着需要进行布局请求的View的集合。但这只是我的猜测,然后我就在<code>ViewRootImpl</code>类的代码中搜索了这个变量出现的地方。发现了一个函数<code>requestLayoutDuringLayout()</code>，我们可以来看看这个函数的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Called by &#123;<span class="doctag">@link</span> android.view.View#requestLayout()&#125; if the view hierarchy is currently</span><br><span class="line">    * undergoing a layout pass. requestLayout() should not generally be called during layout,</span><br><span class="line">    * unless the container hierarchy knows what it is doing (i.e., it is fine as long as</span><br><span class="line">    * all children in that container hierarchy are measured and laid out at the end of the layout</span><br><span class="line">    * pass for that container). If requestLayout() is called anyway, we handle it correctly</span><br><span class="line">    * by registering all requesters during a frame as it proceeds. At the end of the frame,</span><br><span class="line">    * we check all of those views to see if any still have pending layout requests, which</span><br><span class="line">    * indicates that they were not correctly handled by their container hierarchy. If that is</span><br><span class="line">    * the case, we clear all such flags in the tree, to remove the buggy flag state that leads</span><br><span class="line">    * to blank containers, and force a second request/measure/layout pass in this frame. If</span><br><span class="line">    * more requestLayout() calls are received during that second layout pass, we post those</span><br><span class="line">    * requests to the next frame to avoid possible infinite loops.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;The return value from this method indicates whether the request should proceed</span><br><span class="line">    * (if it is a request during the first layout pass) or should be skipped and posted to the</span><br><span class="line">    * next frame (if it is a request during the second layout pass).&lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> view the view that requested the layout.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@return</span> true if request should proceed, false otherwise.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">requestLayoutDuringLayout</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (view.mParent == <span class="keyword">null</span> || view.mAttachInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// Would not normally trigger another layout, so just let it pass through as usual</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!mLayoutRequesters.contains(view)) &#123;</span><br><span class="line">           mLayoutRequesters.add(view);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">           <span class="comment">// Let the request proceed normally; it will be processed in a second layout pass</span></span><br><span class="line">           <span class="comment">// if necessary</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Don't let the request proceed during the second layout pass.</span></span><br><span class="line">           <span class="comment">// It will post to the next frame instead.</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的注释，官方已经给出了很明确的解析。但有的同学可能英语不太好，我还是先简单的来讲一下注释的内容吧。<br>首先这个函数是在<code>view tree</code>正在进行的布局传递过程<code>layout pass</code>的时候由<code>requestLayout()</code>调用的。但通常情况下<code>requestLayout()</code>不会在布局过程中调用，除非<code>container hierarchy</code>（就是整个View树的层级）知道它自己当前的状态（例如当<code>container hierarchy</code>中所有的子View都完成了测量和在布局过程<code>layout pass</code>结束时完成布局的状态下是可以调用的）。如果<code>requestLayout()</code>在一个<code>frame</code>（这里的<code>frame</code>应该是View的一次绘制流程，即一次完整的<code>measure，layout，draw</code>过程）进行的过程中被调用了，我们需要将所有要求进行布局的View进行注册（记录起来）。在<code>frame</code>结束的时候，我们检查注册过的View，看看是否还有那些没有被正确的处理View进行布局请求。如果有的话，我们将<code>view tree</code>的所有标记清除，得到一个空白的容器，然后在本次<code>frame</code>强制的执行第二次<code>request/measure/layout</code>过程。如果在第二次布局时还收到<code>requestLayout()</code>的调用，我们把这次的布局请求延迟到下一个<code>frame</code>，以此来避免进入死循环。<br>上面就是注释中所说的东西，简单的来讲，这个函数就是用来判断当前<code>frame</code>是否接受在布局过程<code>layout pass</code>中View的重新布局请求。而且这个函数的代码逻辑也很简单，首先传进来的<code>view</code>参数就是请求重新布局的View对象，第一个条件判断<code>(view.mParent == null || view.mAttachInfo == null)</code>表示view没有父布局或view没有所属的窗口，简单来说就是该View不会触发其他的布局。所以接受布局请求返回<code>true</code>。接着就将view不重复地添加到<code>mLayoutRequesters</code>集合中，然后根据<code>mHandlingLayoutInLayoutRequest</code>来判断当前是否正在进行布局请求的处理。若正在进行布局请求的处理就返回<code>false</code>，将当前的view的布局请求放到下一次<code>frame</code>进行，否则就接受请求，并在第二次布局过程中处理。</p>
<p>理解了这个函数后在回过来看我们的<code>performLayout()</code>的代码就简单不少了。但我发现<code>performLayout()</code>的代码里还有一个比较关键的函数<code>getValidLayoutRequesters()</code>。这个函数看它的名字就知道是为了得到前面所说的有布局请求的View的集合。但我们前面讲了将在布局过程<code>layout pass</code>中发生的<code>requestLayout()</code>分成了两种情况，那它又是怎样进行处理的呢？我们可以先到<code>getValidLayoutRequesters()</code>的代码中先看看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * This method is called during layout when there have been calls to requestLayout() during</span><br><span class="line">    * layout. It walks through the list of views that requested layout to determine which ones</span><br><span class="line">    * still need it, based on visibility in the hierarchy and whether they have already been</span><br><span class="line">    * handled (as is usually the case with ListView children).</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> layoutRequesters The list of views that requested layout during layout</span><br><span class="line">    * <span class="doctag">@param</span> secondLayoutRequests Whether the requests were issued during the second layout pass.</span><br><span class="line">    * If so, the FORCE_LAYOUT flag was not set on requesters.</span><br><span class="line">    * <span class="doctag">@return</span> A list of the actual views that still need to be laid out.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> ArrayList&lt;View&gt; <span class="title">getValidLayoutRequesters</span><span class="params">(ArrayList&lt;View&gt; layoutRequesters,</span><br><span class="line">           <span class="keyword">boolean</span> secondLayoutRequests)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">       <span class="keyword">int</span> numViewsRequestingLayout = layoutRequesters.size();</span><br><span class="line">       <span class="comment">// 用于暂存有布局请求的view</span></span><br><span class="line">       ArrayList&lt;View&gt; validLayoutRequesters = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 遍历每个需要请求布局的view</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numViewsRequestingLayout; ++i) &#123;</span><br><span class="line">           View view = layoutRequesters.get(i);</span><br><span class="line">           <span class="comment">// 判断是否需要检查和清除view的flag</span></span><br><span class="line">           <span class="keyword">if</span> (view != <span class="keyword">null</span> &amp;&amp; view.mAttachInfo != <span class="keyword">null</span> &amp;&amp; view.mParent != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (secondLayoutRequests || (view.mPrivateFlags &amp; View.PFLAG_FORCE_LAYOUT) ==</span><br><span class="line">                           View.PFLAG_FORCE_LAYOUT)) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> gone = <span class="keyword">false</span>;</span><br><span class="line">               View parent = view;</span><br><span class="line">               <span class="comment">// Only trigger new requests for views in a non-GONE hierarchy</span></span><br><span class="line">               <span class="comment">// 只触发`view tree`层级结构中可见view的布局请求</span></span><br><span class="line">               <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((parent.mViewFlags &amp; View.VISIBILITY_MASK) == View.GONE) &#123;</span><br><span class="line">                       gone = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (parent.mParent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                       parent = (View) parent.mParent;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       parent = <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!gone) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (validLayoutRequesters == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       validLayoutRequesters = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 将需要处理的view加入到返回集合</span></span><br><span class="line">                   validLayoutRequesters.add(view);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断是否为第2次获取view集合</span></span><br><span class="line">       <span class="keyword">if</span> (!secondLayoutRequests) &#123;</span><br><span class="line">           <span class="comment">// If we're checking the layout flags, then we need to clean them up also</span></span><br><span class="line">           <span class="comment">// 遍历集合里所有的view，并将其中的flag重置</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numViewsRequestingLayout; ++i) &#123;</span><br><span class="line">               View view = layoutRequesters.get(i);</span><br><span class="line">               <span class="keyword">while</span> (view != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                       (view.mPrivateFlags &amp; View.PFLAG_FORCE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">                   view.mPrivateFlags &amp;= ~View.PFLAG_FORCE_LAYOUT;</span><br><span class="line">                   <span class="keyword">if</span> (view.mParent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                       view = (View) view.mParent;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       view = <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 清除参数集合中的所有view，给下一次`frame`提供一个空的容器</span></span><br><span class="line">       layoutRequesters.clear();</span><br><span class="line">       <span class="keyword">return</span> validLayoutRequesters;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的功能就是遍历参数<code>layoutRequesters</code>里的每个View，根据每个View在<code>view tree</code>层级结构中是否可见以及是否已被处理，来判断哪些view仍然需要布局。其中第2个参数<code>secondLayoutRequests</code>表示获取的view集合是否是在一次<code>frame</code>里的第2次获取。因为我们需要将布局请求分为两种，在第2次获取view的集合时得到的是在下一次<code>frame</code>中需要进行处理的view，而代码中是通过第2个参数<code>secondLayoutRequests</code>来区分。<br>简单的来说，这个函数就是用来获取当前<code>frame</code>中需要进行布局处理的view集合或者获取下一次<code>frame</code>时需要进行布局处理的view集合。</p>
<p>知道了<code>mLayoutRequesters</code>这个成员属性和<code>getValidLayoutRequesters()</code>函数的意义后我们可以来继续分析我们的<code>performLayout()</code>的代码了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前请求布局的View的数量</span></span><br><span class="line"><span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line"><span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前`frame`需要进行处理布局请求的View的集合</span></span><br><span class="line">    ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 表示当前正在处理布局请求</span></span><br><span class="line">        mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">        <span class="comment">// 对集合中的每个view并对它进行新的布局请求，进行测量和布局</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">            view.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对整个View树进行重新测量</span></span><br><span class="line">        measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        <span class="comment">// 表示当前正在布局                 </span></span><br><span class="line">        mInLayout = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 进行第2次布局</span></span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">        <span class="comment">// 表示布局请求处理完毕</span></span><br><span class="line">        mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 获取下次`frame`需要进行布局处理的view集合</span></span><br><span class="line">        validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">            <span class="comment">// 将相应布局请求发生到下一次`frame`中进行处理</span></span><br><span class="line">            getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                        <span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                        ......... </span><br><span class="line">                        view.requestLayout();</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">..........</span><br><span class="line"><span class="comment">// 表示布局结束</span></span><br><span class="line">mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我在代码中已经做了详细的注释，我相信通过对<code>mLayoutRequesters</code>和<code>getValidLayoutRequesters()</code>两个关键点的讲解后，大家都能轻易的理解<code>performLayout()</code>的基本逻辑。那么现在我们要进入到View真正进行布局的地方—<code>layout()</code>.</p>
<h3 id="揭开layout-的面目"><a href="#揭开layout-的面目" class="headerlink" title="揭开layout()的面目"></a>揭开<code>layout()</code>的面目</h3><p><code>layout(int l, int t, int r, int b)</code>这是我们的函数原型，4个参数分别是由父布局传进来的，代表view在父布局中所放置的位置信息，分别为距离父布局的上下左右的位置。下面给出示意图。<br><img src="http://o7x6n1hmo.bkt.clouddn.com/image/position.png" alt=""></p>
<p>知道了参数的意义后，话不多说，马上让我们的主角登场吧！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Assign a size and position to a view and all of its</span><br><span class="line">    * descendants</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;This is the second phase of the layout mechanism.</span><br><span class="line">    * (The first is measuring). In this phase, each parent calls</span><br><span class="line">    * layout on all of its children to position them.</span><br><span class="line">    * This is typically done using the child measurements</span><br><span class="line">    * that were stored in the measure pass().&lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;Derived classes should not override this method.</span><br><span class="line">    * Derived classes with children should override</span><br><span class="line">    * onLayout. In that method, they should</span><br><span class="line">    * call layout on each of their children.&lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> l Left position, relative to parent</span><br><span class="line">    * <span class="doctag">@param</span> t Top position, relative to parent</span><br><span class="line">    * <span class="doctag">@param</span> r Right position, relative to parent</span><br><span class="line">    * <span class="doctag">@param</span> b Bottom position, relative to parent</span><br><span class="line">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 判断在布局前是否需要测量</span></span><br><span class="line">       <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">           onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">           mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">       <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">       <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">       <span class="keyword">int</span> oldR = mRight;</span><br><span class="line">	<span class="comment">// 判断当前的View的显示模式的并进行边界的设置，并以此来判断View的布局大小和位置是否有所改变</span></span><br><span class="line">       <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">               setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">       	<span class="comment">// 进行布局</span></span><br><span class="line">           onLayout(changed, l, t, r, b);</span><br><span class="line">           mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">           ListenerInfo li = mListenerInfo;</span><br><span class="line">           <span class="comment">// 执行布局的监听接口，像onClickListener等监听接口一样</span></span><br><span class="line">           <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                       (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">               <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                   listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 设置相应的flag</span></span><br><span class="line">       mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">       mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我先来解析一下文档注释的内容吧。首先这个函数是给View和它的后代节点（在<code>view tree</code>上）分配一个大小和位置，将它们布局在窗口上。这是布局机制的第2个阶段（第1阶段是测量阶段）。在这个阶段<code>view tree</code>上的<br>每个父阶段都调用孩子节点的<code>layout()</code>函数来放置它们，而且使用的是孩子节点在测量过程<code>measure pass</code>中保存的测量值。View的派生类不应该重写这个函数来实现自定义布局，而应该重写<code>onLayout()</code>函数，并在<code>onLayout()</code>中对它的孩子进行布局。<br>好了，解析完文档的内容后我们来分析代码吧。代码的逻辑也并不复杂，首先通过View的<code>flag</code>判断在布局前是否需要进行测量。然后根据window的模式来对View进行布局。<br>下面我们来看看<code>onLayout()</code>这个函数吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Called from layout when this view should</span><br><span class="line">    * assign a size and position to each of its children.</span><br><span class="line">    *</span><br><span class="line">    * Derived classes with children should override</span><br><span class="line">    * this method and call layout on each of</span><br><span class="line">    * their children.</span><br><span class="line">    * <span class="doctag">@param</span> changed This is a new size or position for this view</span><br><span class="line">    * <span class="doctag">@param</span> left Left position, relative to parent</span><br><span class="line">    * <span class="doctag">@param</span> top Top position, relative to parent</span><br><span class="line">    * <span class="doctag">@param</span> right Right position, relative to parent</span><br><span class="line">    * <span class="doctag">@param</span> bottom Bottom position, relative to parent</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个函数在<code>View</code>类下的实现是空的函数体。这就说明了我们需要在子类来重写<code>onLayout()</code>函数来完成我们的自定义布局。通常情况下，<code>ViewGroup</code>是需要实现该函数的，因为它需要处理子View的布局。既然这样，我们就来看一下Android提供的<code>FrameLayout</code>类所实现的<code>onLayout()</code>的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 对子View进行布局</span></span><br><span class="line">       layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom,</span><br><span class="line">                                 <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 得到子View的数量</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">       </span><br><span class="line">	<span class="comment">// 计算得到FrameLayout的上下左右</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line">       </span><br><span class="line">	<span class="comment">// 遍历每一个子View，按照FrameLayout的属性对子View进行布局</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 只对属性不为GONE的view进行布局</span></span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">           </span><br><span class="line">           	<span class="comment">// 得到子View的布局参数</span></span><br><span class="line">               <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               </span><br><span class="line">			<span class="comment">// 得到子View测量后的宽高</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> childLeft;</span><br><span class="line">               <span class="keyword">int</span> childTop;</span><br><span class="line">               </span><br><span class="line">			<span class="comment">// 获取View的gravity属性</span></span><br><span class="line">               <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">               <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                   gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">			<span class="comment">// 得到FrameLayout的布局方向，RTL或LTR</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 根据子View的gravity属性和FrameLayout的布局方向</span></span><br><span class="line">               <span class="comment">// 设置布局开始和结束的位置，是从左边开始，到右边结束；还是从右边开始，到左边结束。</span></span><br><span class="line">               <span class="comment">// 得到一个代表水平布局方向的值</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">               </span><br><span class="line">			<span class="comment">// 下面的两个switch语句分别根据布局的垂直方向属性和水平方向属性</span></span><br><span class="line">               <span class="comment">// 计算子View的上左位置，即Top和Left（将边距考虑在内）</span></span><br><span class="line">               <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                       childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                       lp.leftMargin - lp.rightMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                       <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                           childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                       childTop = parentTop + lp.topMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                       childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                       lp.topMargin - lp.bottomMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                       childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childTop = parentTop + lp.topMargin;</span><br><span class="line">               &#125;</span><br><span class="line">			<span class="comment">// 对子View进行布局</span></span><br><span class="line">               child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然代码有点长，但逻辑都非常的清晰，而且我在代码中也做了相应的注释，相信大家能很容易的就看得明白。</p>
<h3 id="requestLayout-与invalidate"><a href="#requestLayout-与invalidate" class="headerlink" title="requestLayout()与invalidate()"></a><code>requestLayout()</code>与<code>invalidate()</code></h3><p>到这里我们的布局过程<code>layout pass</code>也分析完毕了。但这里还有一个疑问，就是我们在分析<code>performLayout()</code>的时候多次提到了<code>requestLayout()</code>这个函数，但却不清楚它的内容，既然这样，我们就来看看<code>requestLayout()</code>的真面目吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Call this when something has changed which has invalidated the</span><br><span class="line">    * layout of this view. This will schedule a layout pass of the view</span><br><span class="line">    * tree. This should not be called while the view hierarchy is currently in a layout</span><br><span class="line">    * pass (&#123;<span class="doctag">@link</span> #isInLayout()&#125;. If layout is happening, the request may be honored at the</span><br><span class="line">    * end of the current layout pass (and then layout will run again) or after the current</span><br><span class="line">    * frame is drawn and the next layout occurs.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;Subclasses which override this method should call the superclass method to</span><br><span class="line">    * handle possible request-during-layout errors correctly.&lt;/p&gt;</span><br><span class="line">    */</span></span><br><span class="line">   <span class="meta">@CallSuper</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 只有在当前的View请求布局，而不是父级层级的View请求布局时</span></span><br><span class="line">           <span class="comment">// 才触发布局时请求的逻辑代码</span></span><br><span class="line">           ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">           <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">	<span class="comment">// 设置相应的布局flag，或操作表示在flag中添加该标志</span></span><br><span class="line">       mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">       mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">       </span><br><span class="line">	<span class="comment">// 判断是否需要对父View进行布局请求</span></span><br><span class="line">       <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">       	<span class="comment">// 调用ViewRootImpl的`requestLayout()`</span></span><br><span class="line">           mParent.requestLayout();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">           mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>照样的，我先讲讲文档注释中的内容。当我们的View的内容发生了改变导致View的布局变得无效（即我们想要的效果没有正确的展现在布局上），这个时候我们可以调用<code>requestLayout()</code>来告诉系统让系统在<code>view tree</code>上执行一次<code>layout pass</code>来刷新布局。如果正在执行布局<code>layout pass</code>的时候调用了<code>requestLayout()</code>，那么布局的请求可能会在当前布局结束的时候重新进行一次<code>layout pass</code>，或者是等到下一次<code>frame</code>的时候才进行布局。如果子类要重写该方法，需要先调用<code>super.requestLayout()</code>以保证能正确的处理各种布局请求。<br>文档所说的与我们在前面分析的<code>requestLayoutDuringLayout()</code>函数时是一样的。如果前面的分析看懂了，那么结合前面的分析，<code>requestLayout()</code>的代码也很容易就能明白。<br>这里有一点需要注意的，就是下面部分的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要对父View进行布局请求</span></span><br><span class="line">   <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">         <span class="comment">// 调用ViewRootImpl的`requestLayout()`</span></span><br><span class="line">         mParent.requestLayout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里根据条件，调用了<code>ViewRootImpl</code>的<code>requestLayout()</code>函数，这个函数就是我在前面的文章中提到过的，调用了<code>scheduleTraversals()</code>的函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且我们也知道了这个函数最后会调用<code>ViewRootImpl</code>的<code>performTraversal()</code>函数，会执行一遍View的<code>measure，layout，draw</code>流程。<br>这就说明了，当View的<code>requestLayout()</code>被调用的时候，我们的整个<code>view tree</code>可能会进行一次<code>measure，layout，draw</code>的过程，这时我们的<code>ViewRootImpl</code>中的<code>performMeasure()</code>和<code>performLayout()</code>会一定被调用，但<code>performDraw()</code>就有可能被调用也有可能不被调用。  </p>
<p>既然讲到了<code>requestLayout()</code>，那就不得不提与它非常密切的<code>invalidate()</code>了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Invalidate the whole view. If the view is visible,</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125; will be called at some point in</span><br><span class="line">    * the future.</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line">    * This must be called from a UI thread. To call from a non-UI thread, call</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #postInvalidate()&#125;.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       invalidate(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    * This is where the invalidate() work actually happens. A full invalidate()</span><br><span class="line">    * causes the drawing cache to be invalidated, but this function can be</span><br><span class="line">    * called with invalidateCache set to false to skip that invalidation step</span><br><span class="line">    * for cases that do not need it (for example, a component that remains at</span><br><span class="line">    * the same dimensions with the same content).</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> invalidateCache Whether the drawing cache for this view should be</span><br><span class="line">    *            invalidated as well. This is usually true for a full</span><br><span class="line">    *            invalidate, but may be set to false if the View's contents or</span><br><span class="line">    *            dimensions have not changed.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">       invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 将View中指定的区域变为无效</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span><br><span class="line">           <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mGhostView != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mGhostView.invalidate(<span class="keyword">true</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (skipInvalidate()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">               || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">               || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">               || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (fullInvalidate) &#123;</span><br><span class="line">               mLastIsOpaque = isOpaque();</span><br><span class="line">               <span class="comment">// 去掉flag中的draw标记，以此来表示view未被绘制</span></span><br><span class="line">               mPrivateFlags &amp;= ~PFLAG_DRAWN;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (invalidateCache) &#123;</span><br><span class="line">               mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">               mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Propagate the damage rectangle to the parent view.</span></span><br><span class="line">           <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">           <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">           <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">               <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">               damage.set(l, t, r, b);</span><br><span class="line">               <span class="comment">// 调用`ViewRootImpl`的`invalidateChild()`</span></span><br><span class="line">               p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Damage the entire projection receiver, if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (mBackground != <span class="keyword">null</span> &amp;&amp; mBackground.isProjected()) &#123;</span><br><span class="line">               <span class="keyword">final</span> View receiver = getProjectionReceiver();</span><br><span class="line">               <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   receiver.damageInParent();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Damage the entire IsolatedZVolume receiving this view's shadow.</span></span><br><span class="line">           <span class="keyword">if</span> (isHardwareAccelerated() &amp;&amp; getZ() != <span class="number">0</span>) &#123;</span><br><span class="line">               damageShadowReceiver();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>注释说了，这个函数会可见的View变成无效的状态，即需要进行重新绘制，这就说明了<code>onDraw()</code>函数将会被调用。<br>上面的代码我们关注的部分是，首先<code>invalidate()</code>函数最终调用的是<code>invalidateInternal()</code>函数。所以我们直接看这个函数。在<code>invalidateInternal()</code>里，通过<code>mPrivateFlags &amp;= ~PFLAG_DRAWN;</code>这句代码将<code>flag</code>相应的位设置为未被绘制。然后可以看到通过<code>p.invalidateChild(this, damage);</code>调用了<code>ViewRootImpl</code>的<code>invalidateChild()</code>。下面就是<code>ViewRootImpl</code>中相关的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, Rect dirty)</span> </span>&#123;</span><br><span class="line">       invalidateChildInParent(<span class="keyword">null</span>, dirty);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">       checkThread();</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_DRAW) Log.v(TAG, <span class="string">"Invalidate child: "</span> + dirty);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (dirty == <span class="keyword">null</span>) &#123;</span><br><span class="line">           invalidate();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span> || mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mTempRect.set(dirty);</span><br><span class="line">           dirty = mTempRect;</span><br><span class="line">           <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span>) &#123;</span><br><span class="line">               dirty.offset(<span class="number">0</span>, -mCurScrollY);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mTranslator.translateRectInAppWindowToScreen(dirty);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (mAttachInfo.mScalingRequired) &#123;</span><br><span class="line">               dirty.inset(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       invalidateRectOnScreen(dirty);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Rect localDirty = mDirty;</span><br><span class="line">       <span class="keyword">if</span> (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;</span><br><span class="line">           mAttachInfo.mSetIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">           mAttachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Add the new dirty rect to the current one</span></span><br><span class="line">       localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</span><br><span class="line">       <span class="comment">// Intersect with the bounds of the window to skip</span></span><br><span class="line">       <span class="comment">// updates that lie outside of the visible region</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> appScale = mAttachInfo.mApplicationScale;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> intersected = localDirty.intersect(<span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">               (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</span><br><span class="line">       <span class="keyword">if</span> (!intersected) &#123;</span><br><span class="line">           localDirty.setEmpty();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">       	<span class="comment">// 关注这里</span></span><br><span class="line">           scheduleTraversals();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需关注上面最后的那句代码<code>scheduleTraversals();</code>即可。这里也调用了<code>scheduleTraversals()</code>，也就是说最终也会调用<code>performTraversals()</code>函数，但是由于没有添加<code>measure</code>和<code>layout</code>的标记到flag中，所以只会调用<code>performDraw()</code>函数。<br>总的来说：</p>
<ul>
<li><code>invalidate()</code>函数会触发<code>performDraw()</code>过程。</li>
<li><code>requestLayout()</code>就会触发<code>performMeasure()</code>和<code>performLayout()</code>过程，也有可肯触发<code>performDraw()</code>。</li>
</ul>
<blockquote>
<p>注意：<code>invalidate()</code>需要在UI线程里被调用，如果要在非UI线程里调用，就需要调用<code>postInvalidate()</code>。</p>
</blockquote>
<p>更多关于<code>invalidate()</code>和<code>requestLayout()</code><br>的信息可以参考这两篇博文：</p>
<ul>
<li><a href="https://www.zybuluo.com/linux1s1s/note/136452" target="_blank" rel="external">Android requestLayout 和 invalidate</a></li>
<li><a href="http://www.jianshu.com/p/effe9b4333de" target="_blank" rel="external">Android View 深度分析requestLayout、invalidate与postInvalidate</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后还是用图片进行总结吧，因为这样最实际。<br><img src="http://o7x6n1hmo.bkt.clouddn.com/image/layout_pass.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
	  
	  <a data-url="http://kevinhqf.github.io/2016/09/26/ViewDetails_04/" data-id="citk6m9ag0011j8869m3x83iw" data_title="Android学习笔记---深入理解View#04" data_summary="上次我们对View的测量过程有了了解，接着这次肯定就是..." class="article-share-link">Share</a>
      
        <a href="http://kevinhqf.github.io/2016/09/26/ViewDetails_04/#disqus_thread" class="article-comment-link">Comments</a>
      

      
	  
      
	  
<span>
Updated:<time datetime="2016-09-26T15:00:29.713Z" itemprop="dateModified">2016-09-26</time>
</span>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/09/22/ViewDetails_03/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android学习笔记---深入理解View#03</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



</section>
        
          
  <div id="toc" class="toc-aside">
  <h2 class="toc-title">Contents</h2>
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#从performLayout-开始出发"><span class="toc-number">1.</span> <span class="toc-text">从performLayout()开始出发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#揭开layout-的面目"><span class="toc-number">2.</span> <span class="toc-text">揭开layout()的面目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requestLayout-与invalidate"><span class="toc-number">3.</span> <span class="toc-text">requestLayout()与invalidate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
    
  </div>

<aside id="sidebar">

  
    
<div class="widget-wrap">
  <h3 class="widget-title">ABOUT ME</h3>
  <ul class="widget about-me">
    
    <li><img class="author" title="About me" src="/images/avatar.jpg" /></li>
    
    
    <li>Hi,I'm Kevin.</li>
    
  </ul>
</div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">Markdown</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/26/ViewDetails_04/">Android学习笔记---深入理解View#04</a>
          </li>
        
          <li>
            <a href="/2016/09/22/ViewDetails_03/">Android学习笔记---深入理解View#03</a>
          </li>
        
          <li>
            <a href="/2016/09/20/ViewDetails_02/">Android学习笔记---深入理解View#02</a>
          </li>
        
          <li>
            <a href="/2016/09/17/ViewDetails_01/">Android学习笔记---深入理解View#01</a>
          </li>
        
          <li>
            <a href="/2016/09/14/CustomView-custom_drawing/">Android学习笔记---重新学习自定义View#02</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    

  

</aside>

        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Kevin HO<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/howiefh/hexo-theme-landscape-f" target="_blank" title="Landscape-F">Landscape-F</a>
    
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'kevinhqf';
  
  var disqus_url = 'http://kevinhqf.github.io/2016/09/26/ViewDetails_04/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>






<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<div class="bottom-btn">

	<a class="icon-gotop" href="javascript:void(0)" title="返回顶部"></a>
	<script src="/js/gotop.js"></script>
	<!--
	<script src="/js/gotop.js"></script>
	-->


	<a class="icon-toc-toggle" href="javascript:void(0)" title="文章目录"></a>
	<!--
	<script src="/js/toc_aside_toggle.js"></script>
	-->

</div>
<script src="/js/toc_aside_toggle.js"></script>


<script src="/js/script.js"></script>







  </div>
</body>
</html>
